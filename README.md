# OperatingSystems

## ЛАБОРАТОРНАЯ РАБОТА №1

### Управление файловой системо

Цель работы: исследовать управление файловой системой с помощью Win32 API.

Задание 1.1. Управление дисками, каталогами и файлами.

1)	Вывод списка дисков
2)	Для одного из выбранных дисков вывод информации о диске и размер свободного пространства
3)	Создание и удаление заданных каталогов
4)	Создание файлов в новых каталогах
5)	Копирование и перемещение файлов между каталогами с возможностью выявления попытки работы с файлами, имеющими совпадающие имена
6)	Анализ и изменение атрибутов файлов

Задание 1.2. Копирование файла с помощью операций перекрывающегося ввода-вывода. (Linux)

## ЛАБОРАТОРНАЯ РАБОТА №2

### Управление памятью

Цель работы: исследовать механизмы управления виртуальной памятью Win32.

Задание 2.1. Исследовать виртуальное адресное пространство процесса.

1)	Получение информации о вычислительной системе
2)	Определение статуса виртуальной памяти
3)	Определение состояния конкретного участка памяти по заданному с клавиатуры адресу
4)	Резервирование региона в автоматическом режиме и в режиме ввода адреса начала региона
5)	Резервирование региона и передача ему физической памяти в автоматическом режиме и в режиме ввода адреса начала региона
6)	Запись данных в ячейки памяти по заданным с клавиатуры адресам
7)	Установку защиты доступа для заданного (с клавиатуры) региона памяти и ее проверку
8)	Возврат физической памяти и освобождение региона адресного пространства заданного (с клавиатуры) региона памяти

Задание 2.2. Использование проецируемых файлов для обмена данными между процессами.

Приложение-сервер: 
Создаётся файл с помощью функции open. Потом с помощью функции fallocate резервируется пространство на диске для указанного файла. 
Потом с помощью функции mmap происходит отображение файла в адресное пространство. 
Если не возникло ошибок, то приложение возвращает адрес спроецированного фрагмента. 
После записывает данные в проецируемый файл. Далее приложение-сервер после завершения прочтения файла клиентом отменяет отображения и удаляет файл.

Приложение-клиент: 
Нужно запустить это приложение, не завершая приложение-сервер. 
Далее открывает проецируемый файл открывается функцией open, его фрагмент проецируется функцией mmap в память. 
Данные, записанные в проецируемый файл в приложении-писателе, считываются приложением-читателем и выводятся на экран.

Реализация взаимодействия двух программ – клиента и сервера, с использованием проецируемого файла, предоставляет пример использования этого механизма. Этот подход обеспечивает быстрый доступ к данным и позволяет программам обмениваться информацией, не заботясь о низкоуровневых операциях чтения и записи на диск. При этом, данные могут быть переданы между процессами без лишней сложности и накладных расходов.

## ЛАБОРАТОРНАЯ РАБОТА №3

### ПРОЦЕССЫ И ПОТОКИ

Цель работы: исследовать механизмы создания и управления процессами и потоками в ОС Windows.

Задание 3.1. Реализация многопоточного приложения с использованием функций Win32 API.

Пункт 1 - создание программы, которая вычисляет число pi с точностью N знаков после запятой по следующей формуле 

![image](https://github.com/user-attachments/assets/c0724f06-b076-42ef-abee-e533bbce593a)

, где N=100000000.

Пункт 2 – замер времени выполнения приложения для разного числа потоков (1, 2, 4, 8, 12, 16). Построение графика и определение числа потоков, при котором достигается наибольшая скорость выполнения по результатам измерений и сравнение результатов


Задание 3.2. Реализация многопоточного приложения с использованием технологии OpenMP.

Пункт 1 – создание программы, которая вычисляет число pi с точностью N знаков после запятой по следующей формуле 

![image](https://github.com/user-attachments/assets/4f9bd0fb-4020-45f8-8d50-d1d432ec3681)
,
где N=100000000. Для распределения работы программы по потокам была использована OpenMP-директива for и динамическое планирование блоками итераций, где Размер блока = 10 * Nстудбилета. (Nстудбилета = 130725) 

Пункт 2 – замер времени выполнения приложения для разного числа потоков (1, 2, 4, 8, 12, 16). Построение графика и определение числа потоков, при котором достигается наибольшая скорость выполнения по результатам измерений и сравнение результатов

WinAPI предоставляет разработчикам Windows широкие возможности для создания многопоточных приложений. С помощью функций и инструментов WinAPI можно управлять потоками, синхронизировать их работу, а также осуществлять управление вводом-выводом и другими аспектами параллельного выполнения кода на уровне операционной системы.
OpenMP, в свою очередь, является стандартом для параллельного программирования на языках C и C++. Он предлагает набор директив, которые позволяют компилятору автоматически распараллеливать циклы, задачи и другие участки кода для эффективного использования многопроцессорных систем.
Оба подхода имеют свои особенности и преимущества. WinAPI предоставляет разработчикам больше гибкости и контроля в управлении потоками, позволяя точно настроить создание, синхронизацию и взаимодействие потоков. Он также предоставляет широкий набор функций для работы с многопоточностью и другими аспектами параллельного программирования на платформе Windows. Однако, использование WinAPI требует более низкоуровневых знаний и может потребовать больше усилий для реализации.
OpenMP, с другой стороны, предоставляет более высокоуровневую и декларативную абстракцию для параллельного программирования. Он позволяет разработчикам указывать директивы для автоматического распараллеливания циклов, задач и других участков кода. Это делает использование OpenMP более простым и доступным, особенно для разработчиков с ограниченным опытом в параллельном программировании.
Выбор между WinAPI и OpenMP зависит от требований вашего проекта. Если вам необходим полный контроль над созданием и управлением потоков, а также доступ к специфическим функциям операционной системы, то WinAPI может быть предпочтительным вариантом. Если же вам нужна более простая и удобная абстракция для распараллеливания кода без необходимости работы с низкоуровневыми функциями, то OpenMP может быть более удобным выбором.
В итоге, оба подхода могут быть эффективными в параллельном программировании, и выбор зависит от ваших предпочтений и требований проекта.

## ЛАБОРАТОРНАЯ РАБОТА №4

### Межпроцессное взаимодействие

Цель работы: исследовать инструменты и механизмы взаимодействия процессов в Windows.

Задание 4.1. Реализация решения задачи о читателях-писателях.

Указания к выполнению:
1. Выполнить решение задачи о читателях-писателях, для чего необходимо разработать консольные приложения «Читатель» и «Писатель»: 
●	Одновременно запущенные экземпляры процессов-читателей и процессов-писателей должны совместно работать с буферной памятью в виде проецируемого файла: 
1.	размер страницы буферной памяти равен размеру физической страницы оперативной памяти; 
2.	число страниц буферной памяти равно сумме цифр в номере студенческого билета без учета первой цифры. 
●	Страницы буферной памяти должны быть заблокированы в оперативной памяти (функция VirtualLock); 
●	Длительность выполнения процессами операций «чтения» и «записи» задается случайным образом в диапазоне от 0,5 до 1,5 сек.;
●	Для синхронизации работы процессов необходимо использовать объекты синхронизации типа «семафор» и «мьютекс»; 
●	Процессы-читатели и процессы-писатели ведут свои журнальные файлы, в которые регистрируют переходы из одного «состояния» в  другое (начало ожидания, запись или чтение, переход к освобождению) с указанием кода времени (функция TimeGetTime). 
Для состояний «запись» и «чтение» необходимо также запротоколировать номер рабочей страницы. 
2. Запустите приложения читателей и писателей, суммарное количество одновременно работающих читателей и писателей должно быть не менее числа страниц буферной памяти. Проверьте функционирование приложений, проанализируйте журнальные файлы процессов, постройте сводные графики смены «состояний» для не менее  5 процессов-читателей и 5 процессов-писателей, дайте свои комментарии относительно переходов процессов из одного состояния в другое. Постройте графики занятости страниц буферной памяти (проецируемого файла) во времени, дайте свои комментарии. 
3. Подготовьте итоговый отчет с развернутыми выводами по заданию.

Задание 4.2. Использование именованных каналов для реализации сетевого межпроцессного взаимодействия.

Указания к выполнению:
1. Создайте два консольных приложения с меню (каждая выполняемая функция и/или операция должна быть доступна по отдельному пункту меню), которые выполняют: 
●	Приложение-сервер создает именованный канал (функция Win32 API – CreateNamedPipe), выполняет установление и отключение соединения (функции Win32 API – ConnectNamedPipe,  DisconnectNamedPipe), создает объект «событие» (функция Win32  API – CreateEvent) осуществляет ввод данных с клавиатуры и их  асинхронную запись в именованный канал (функция Win32 API – WriteFile), выполняет ожидание завершения операции ввода-вывода (функция Win32 API – WaitForSingleObject); 
●	Приложение-клиент подключается к именованному каналу (функция Win32 API – CreateFile), в асинхронном режиме считывает содержимое из именованного канала файла (функция Win32 API – ReadFileEx) и отображает на экран. 
2. Запустите приложения и проверьте обмен данных между процессами. Запротоколируйте результаты в отчет. Дайте свои комментарии в отчете относительно выполнения функций Win32 API. 
3. Подготовьте итоговый отчет с развернутыми выводами по заданию.

Реализация программы
Со стороны сервера:
1.	Создать именованный канал, функция – CreateNamedPipe.
2.	Создать событие, функция – CreateEvent.
3.	Вызвать функцию ConnectNamedPipe, которая ожидает соединения со стороны клиента.
4.	Далее при соединении с клиентом помещаем сообщение в канал, функция - WriteFile. (первым параметром – дескриптор канала).
5.	После обработки запроса вызываем функции для закрытия канала - DisconnectNamedPipe, CloseHandle.

Со стороны клиента:
1.	Ожидать освобождения сервера, функция - WaitNamedPipe.
2.	Вызвать функцию CreateFile, в качестве первого параметра имя канала, а второй тип доступа – чтение.
3.	Получить ответ, функция - ReadFileEx. (первым параметром – дескриптор канала).
4.	Закрыть канал после того, как обмен сообщениями закончен - функция CloseHandle.

